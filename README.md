# my-pay

마이 페이는 무슨 일을 할까?
마이 페이 - 간편 결제 시스템 like 카카X 페이, 사과 페이 등...

비즈니스 능력을 기준으로, 고객 입장에서의 서비스(Micro Service X) 에서 마이 페이에 필요한 기능을 정의

- 회원 가입 및 정보 변경 기능
  - Membership Service! 이미 식별 완료!
- [회원 to 회원] [회원 to 일반 은행계좌] 간 간편 송금 기능
  - 일단 머니의 개념부터!!
- 가맹점에서의 결제 기능 + 가맹점 정산 기능

## 머니의 이해1 - 선불 충전 금액
James :   우리 와이프는 나에게 매월 20만원을 마이페이로 용돈을 주지! -> "**마이 머니**" 정의 해요
사용자가 마이 페이에 송금을 하면 "마이 페이 법인 계좌"에 송금이 된다. 그리고 나서 사용자 계좌에서 돈이 빠지고 
"마이 페이" SQL에 저장되어 마이 페이에 돈이 있다는것을  표현할 수 있다.
## 머니의 이해 2 - 펌뱅킹 !?
항상 10,000원씩 충전되던 이유
결제 시 10,000원 넘으면, 정확한 금액으로 충전되는 이유
송금 메뉴에 가면, 각 서비스마다 이체 가능한 은행 목록이 다른 이유
#### 펌뱅킹!
은행의 기능을 시스템적으로 이용하기 위한 수단이 시스템을 사용하는 회사 입장에서는 

개별적인 은행마다 별도의 계약을 맺고 수수료 지불

펌뱅킹 기능 사용마다 은행에 수수료를 지불해야만 해요.
- 은행 거래 즉 계좌 간 돈의 이동을 의미
- 입/출금 이행 요청 마다 고정금액 수수료 지불

## 송금시 어떤 일들이 일어날까? -> 돈을 보내는일

- [회원 to 회원]
  - 단순 선불 충전 금액(머니)의 이동 트랜잭션
    - 잔액 부족 시, 최소 10,000원 단위로 충전 후 이동

- [회원 to 일반 은행 계좌] 간 간편 송금 기능
  - 선불 충전 금액(머니)에서 타행의 실제 계좌로의 금액 이동
    - 마이 페이 법인 계좌의 이해가 필요해요.

### 마이 페이가 하는 일을 비즈니스 능력 기준으로 정의해 보자
비즈니스 능력을 기준으로, 고객 입장에서의 서비스(Micro Service X)에서 마이 페이에 필요한 기능을 정의

- 회원 가입 및 정보 변경 기능
  - Membership Service + [계좌 연결] 기능

- [회원 to 회원] / [회원 to 일반 은행 계좌] 간 간편 송금 기능
  - 회원 간 잔액 이동 비즈니스 로직
  - 외부 실제 은행 관리 시스템(모듈) - 뱅킹

- 가맹점에서의 결제 기능 + 정산 기능
  - 가맹점 관리 시스템 + 가맹점 계좌 등록
  - 결제 시스템 + 크론잡을 통한 정산 기능

--> 모놀리식 형태로 먼저 설계해보자
## 모놀리스 아키텍처에서의 멀티 모듈 마이 페이
- **회원 관리 시스템 (Membership)**
- **외부 은행 관리 - 펌뱅킹 시스템(Baking)**
- **머니 관리 시스템 (Money)**
- **가맹점 관리 시스템 (Franchise)**
- **결제 및 전표 생성 시스템 (Payment)**

**송금 ?**
- **단순 비즈니스 로직**
**정산 ?**
- **단순 Cron Job**

### 모놀리스 아키텍처에서의 멀티 모듈 마이 페이

SQL <-- Money, Franchise, Payment, Banking --> Real Bank
                                   ,Membership

## 결론
**앞으로의 계획**
간편 결제 시스템이 무엇인지 이해했어요.
Monolithic (One DB) 기준으로, 논리적인 아키텍처도 설계해 보았어요.

이렇게 설계해본 아키텍처를 MSA로 가기 위한 첫 단계인 분리/분해 부터 해보기 전에
분리 / 분해를 어떻게 하면 좋을지에 대한 이론 (비즈니스 능력 기반 / 하위 도메인 기반) 학습
분리 / 분해의 과정에서 기존의 모놀리식과 동시에 운영을 하기 위한 방안의 이론적 학습

하위 도메인 기반 분리 / 분해를 통한 MSA 마이 페이의 서비스 정의!

## 분해 = 비즈니스 능력(Business Capability)을 기준으로 서비스를 정의 하는일
왜 분해 / 통합이 어려울까?
MSA에서 분리 / 분해의 의미는
**"Business Capability를 가질수 있는 방향으로 서비스를 정의 하는 일"** -> 통합이 될 수도!

수 많은 복잡한 비즈니스가 있는 시스템에서 각 서비스가 Business Capbility를 
최대한 가질 수 있도록 적절하게 서비스를 정의하는 일

각 서비스별로 하나의 DB를(MSA) 가진다는 관점에서, 각 서비스 간 적절한 관계를 통해 Business Capability 확보하는 것이 관건!

**어떤 기준에 따라서? 어떤 지침에 따라서? 분리/분해/통합 하면 좋을지가 Business Capability를 가질 수 있을까??**
**--> 비즈니스 동작 / 하위 도메인 패턴이 그 수단이 되어 줄 수 있어요.** 
 하위 도메인(Sub-Domain) --> 도메인 주도 설계(Domain-Driven Design, DDD)에서 나온 개념!

주문 
- 주문 서비스 (고객 입장)
- 주문 접수
  - 주문을 "잘" 접수하는 것에 집중
    - 비동기 통신 파턴(큐잉) 등의 스택에 집중
- 주문 결제
  - 받은 주문에 대한 결제를 "잘"하는 것에 집중
    - 외부 결제 모듈의 통신 or 낮은 수수료를 위한 방안 찾는 데 집중
- 주문 단계에서의 추천
  - 주문 과정에서 "적절한" 방식으로 추가 상품 구매를 유도 집중 
    - AI/머신 러닝 활용으로 고객 별 최적화에 집중

# 도메인 주도 설계(DDD)
## 유비쿼터스 언어
복잡한 도메인을 이해하고 해결하기 위한 팀(해결을 위해 모인 집단)이 공통으로 쓰기 위한 언어들의 약속
개발자와 비개발자가 문제(도메인)을 해결하기 위해 사용할 언어들의 의미에 대한 약속 모음!
## 도메인 모델
유비쿼터스 언어를 사용하여, 비즈니스 요구사항을 만족하기 위해서 표현하기 위해
도메인들의 핵심 개념과 규칙을 표현하는 **객체들의 관계**로 구성됨
ex) 주문 서비스, 음식 관리 서비스, 배달 서비스
비즈니스 = 비즈니스 동작(해결해야할 문제)들의 모음
도메인 = 그리고 이 문제들을 핵심 개념과 규칙(객체 형식)으로 표현하는 것
도메인 모델 = 이런 객체들 간의 관계까지 표현한 것

하지만, 그저 이렇게 도메인을 식별하기만 해서는 도메인 모델을 그리는 의미와 목적이 부족할 수 있음
** 목적 - 도메인들의 핵심 개념과 규칙을 표현하여 적절하게 분ㄹ리할 수 있도록 돕는 것
그래서, 아래와 같은 개념들이 있고 이러한 개념들은 도메인 간의 핵심 개념과 규칙을 이해하는 데 도움을 줌

**엔티티(Entity): 하나의 객체를 의미하며, 하나의 테이블 모델로서 존재할 수 있는 데이터들의 묶음**
**어그리거트(Aggregat): 데이터 변경의 단위로 다루는 연관된 엔티티들의 묶음 (관련된 객체들의 집합)**
**어그리거트 루트(Aggregate Root): 어그리거트(집합)에서 도메인의 중심을 의미하는 엔티티를 의미**
## Bounded Context
- 정의한 여러 도메인(모델, 문제영역)들을 기준으로, 각 도메인 모델들의 관계 표현 시
    각 모델들은 상호 배타적인 무제를 해결해야만 한다는 DDD의 핵심원칙!
- **주문 서비스 - 고객 입장**
  - 특정 음식점의 음식들을 주문할 수 있다.
    - **주문 접수**
      - 주문을 "잘" 접수하는 것에 집중
        - 비동기 통신 패턴(큐잉) 등의 스택에 집중
    - **주문 결제**
      - 받은 주문에 대한 결제를 "잘"하는 것에 집중
        - 외부 결제 모듈의 통신 or 낮은 수수료를 위한 방안 찾는데 집중
    - **주문 단계에서의 추천**
      - 주문 과정에서 "적절한" 방식으로 추가 상품 구매를 유도 집중
        - AI/머신 러닝 활용으로 고객 별 최적화에 집중
하위 도메인들은 상호 배타적인 문제를 가지고 있어야한다가 Bounded Context의 핵심원칙

## 하위 도메인
정의한 도메인 모델들을 Bounded-Context 원칙에 따라,
    Business Capability 를 높일 수 있는 방식으로 분리해야 한다는 원칙
즉, 분명한 Bounded-Context를 가지는 어그리거트 간의 관계와
    각 어그리거트 별로 어그리거트 루트로 분리된 어그리거트는 하위 도메인이다.

**Bunded-Context를 가질 수 있는 하위 도메인들을 각 서비스로 식별할 수 있다는 개념(패턴)이 "하위 도메인 패턴에 의한 서비스 식별!"**

## 분리 지침, 가이드
"하위 도메인"패턴은 Bounded Context에 따라 도메인을 분리해야 한다는 원칙.
그렇다면, Bounded Context 만 만족한다면 무조건 부리해도 되나요? 어디까지 분리해야 하나요?

추가적으로 2가지 원치이 "분리 지침"이 되어줄 수 있음. (from, Uncle Bob, 로버트 C. 마틴 (Robert cecil Martin))

**단일 책임 원칙(SRP, Single Responsibility Principle)**
- "클래스는 오직 하나의 변경 사유를 가져야 한다."
**공동 폐쇄 원칙 (CCP, Common Closure Principle)**
- "패키지의 클래스들은 동일한 유형의 변경에 대해 닫혀 있어야 한다. 패키지에 영향을 주는 변경은 그 패키지에 속한 모든 클래스에 영향을 끼친다."
- 동일한 사유로 변경되는 클래스들은 동일 패키지에! "주문 결제"시 항상 결제 이력 업데이트
  - 결제 이력 패키지는 "주문 결제"와 동일한 패키지에

## 모노리스 환경에서 MSA로 분해 과정에서의 장애물
### 네트워크 지연(Network Latency)
Case Monolithic. 배달 주문 앱을 통해, 고객이 카드 결제가 포함된 주문 접수를 요청한다면?
요청부터 응답까지 걸리는 시간에 포함되는 것은?
1. 모바일 클라이언트 -> 주문 접수 모듈
2. 주문 접수 모듈/결제 모듈에서의 비즈니스 로직 + [[DB Access]]
3. 결제 모듈에서 카드사로 통신 (e.g. HTTP Call)
4. 카드사 로부터의 Response 후, 추가 비즈니스 로직 + [[DB Access]]
5. 모바일 클라이언트 리턴
Case MSA. 배달 주문 앱을 통해, 고객이 카드 결제가 포함된 주문 접수를 요청한다면?
요청부터 응답까지 걸리는 시간에 포함되는 것은?
1. 모바일 클라이언트 -> 주문 접소 서비스
2. 주문 접수 서비스에서의 비즈니스 로직 + [[DB Access]]
3. **주문 접수 서비스 -> 결제 서비스 통신 (e.g. HTTP Call)**
4. 결제 서비스에서의 비즈니스 로직 + [[DB Access]]
5. **결제 서비스에서 카드사로 통신 (e.g. HTTP Call)**
6. 카드사 로 부터의 Response 후, 결제 서비스에서 추가 비즈니스 로직 + [[DB Access]]
7. 결제 서비스 로부터의 Response 후, 주문 접수 서비스에서 추가 비즈니스 로직 + [[DB Access]]
8. 모바일 클라이언트로 응답

네트워크 Call이 MSA에서 더 많이 하게 된다. 그래서 모노리스보다 네트워크 지연이 될 확률이 높을 수 있다.
모노리스에서 발생하지 않았을 문제가 MSA에서는 일어날 수도 있다.
네트워크 지연이 생김에도 불구하고 힘들더라도 모니터링 시스템을 더 높이던가 해서 극복을 해야한다.
### 트랜잭션
Case Monolithic. 배달 주문 앱을 통해, 고객이 카 드 결제가 포함된 주문 접수를 요청한다면?
요청부터 응답까지 걸리는 시간에 포함되는 것은?
1. 모바일 클라이언트 -> 주문 접수 모듈
2. 주문 접수 모듈/ 결제 모듈에서의 비즈니스 로직 + [[DB Access]]
3. 결제 모듈에서 카드사로 통신 (e.g. HTTP Call)
   1. 카드사 로부터의 Response 후, 추가 비즈니스 로직 + [[DB Access]]
   2. (실패 시) 실패에 대한 비즈니스 로직 + [[DB Access]]
4. 모바일 클라이언트 리턴

### 가용성
요청에 대해서, "해야하는 일"이 얼마나 오랜 시간 운영이 가능한지를 나타내는 정도
Case MSA. 배달 주문 앱을 통해 고객이 카드 결제가 포함된 주문 접수를 요청한다면?
![MSA_가용성_1.png](images/MSA_가용성_1.png)

외부의 경우 불가피 하지만, 내부 통신 구간에서 문제가 생긴다면..
1. 내부 모듈을 통해 **호출 가능했을 수** 있던 Call에 문제 가능성 UP
--> 분해로 인해 필연적으로 가용성 Down!

**"요청이 다음 스텝(모듈/서비스)으로 얼마나 잘 갈 수 있을지!?"**
--> 비동기 통신이 하나의 해결 방법이 될 수도!
--> 가용성 문제 해결을 위해 "서킷 브레이커" 적용도 가능

## 분해만 하면 끝인가요?
(분해 과정에서 버시스 운영_스트랭글러 패턴과 통합 글루)
### 분해가 어려운 건 알았어요. 그러면 전환은 어떻게 하나요?
전환을 비롯해 새롭게 구축하는 상황에서조차, "분해"가 어렵다는 것은 알았어요.
안그래도 어려운 분해를, 기존 운영중인 모놀리식에서 전환은 어떻게 하면 좋을까요?

**모놀리식에서 MSA로 전환을 위해 고려해야할 것들을 해결해야겠죠? 마이그레잉션의 영역**
모놀리식과 MSA의 큰 차이점을 위해 한번에 개발 후 빅뱅?
"완전히 뜯어 고치는 것"이 보장 하는 것은 "전부 다 뜯어 고친다"는 사실 뿐 - 마틴 파울러 (Martin Fowler)

서비스 단위로, 하나씩 하나씩 분해하며 소프트하게 전환하는 방법을 알아보자!!

### 스트랭글러 (Strangler) - 덩굴 패턴?
![MSA_스트랭글러_패턴.png](images/MSA_스트랭글러_패턴.png)
Monolothic DB를 Micro Service DB로 마이그레이션이 목적
![MSA_스트랭글러_패턴_2.png](images/MSA_스트랭글러_패턴_2.png)
운영하고 있는 환경에서 MSA 환경으로 변환하기 위해서 필요한 통합 글루가 필요하다.
![MSA_스트랭글러_패턴_3.png](images/MSA_스트랭글러_패턴_3.png)
마이크로 서비스에서 처리된 데이터를 Event로 처리해서 모놀리스 환경으로 통신해서 처리한다.
그래서 이렇게 하나씩 마이크로 서비스로 변경해서 처리한다.

![MSA_통합글루.png](images/MSA_통합글루.png)
기존에 있던 모노리스에 있던 서비스 조회 담당을 없앨 수 있는 조건은 결제 서비스에서 모든 처리를 서비스 처리 담당 DB로 하게 되면 된다.\

### 결론 
전환을 비롯해 새롭게 구축하는 상황에서 조차, 물리적인 한계로 "분해"가 어렵다는 것은 알았다.

그리고 이런 한계들을, 다양한 패턴들을 통해 극복 가능하다는 것도 알았다.
물론 잊지 말아야할 것은, 이 ㅐㅍ턴들을 구현하는 것도 모두 시간과 비용이 필요하다는 점이다.
**- 한계: 네트워크 지연, 트랜잭션, 가용성**

이렇게 극복한 패턴들을 이용해서, 기존에 운영중인 Monolithic으로부터 MSA로 전환하는 방법도 알아 봤다.

앞으로의 계획

기술의 목적과 한계들에 대해 항상 생각하면서..

"마이 페이" 라는 시스템이 하는 일이 무엇인지를 생각하면서, MSA 아키텍처를 구성해 보고
기존에 설계해 보았던 마이 페이 Monolithic 아키텍처와는 어떻게 달라질 수 있을지 살펴볼 예정!

## 마이 페이의 시스템 작업과 서비스 식별하기
### MSA 아키텍처를 위한 Micro Service를 식별하기 위해서...

#### 1단계
기능 요건 정의하기 (**from 도메인 전문가**)
  - 기능 요건이란, 시스템이 갖춰야 할 요건을 정의하는 것
  - 도메인 레벨에서, 해당 시스템은 어떤 것을 해야한다에 대한 요건들
### 2단계
기능 요건 으로 부터 사용자(액터) 시나리오, 케이스 정의하고 **도메인 모델** 도출
### 3단계
2단계에서 도출한 시나리오를 만족하기 위해, 마이 페이라는 시스템이 해야할 작업 식별하기
### 4단계
식별된 작업을 기준으로, "도메인" 즉 "서비스"를 정의하기. (비즈니스 능력별 기준 or/and 하위 도메인별-(sub domain) 분해)

하지만, 절대적인 것은 없다! 그래서 MSA 컨설팅을 받기도 한다.

#### 기능 요건 정의해보기
시스템이 갖춰야 할 요건을 정의하는 것.
시스템에 참여하는 주체가 (Who) --> 고객으로서 / 마이페이 직원으로서 / 가맹점주로서
어떤 수단을 통해서(Through) --> 외부 은행과 통신, 주기적인 정산 작업을 진행, 파라미터 변경(이벤트 관리, 수수료율 조정, ...) ....
무엇을 이루고자 하는지(What) --> 머니충전: 선불 충전 금액의 관리 | 송금: 내가 소지한 돈의 이동 | 가맹점 정산, 결제, 회계 시스템 연계,,,,

#### 도메인 모델 도출해보기
기능요건으로부터, 도메인 모델 (관리가 필요한 정보들)을 도출해 보는 작업
고객으로서 / 마이페이 직원으로서 / 가맹점 주로서 --> 법인 계좌 관리, 직원 관리, 인증 도메인 | 고객(개인/가맹점), 인증 도메인 | 외부 은행 관리, 펌뱅킹 수수료 관리, 계약 등 관리 (은행)  | 정산 주기, 정산 조건, 수수료 등 관리 (정산)
뱅킹, 정산, 파라미터 변경(이벤트, 수수료율 조정, ...) ... --> 수수료를 포함한 비즈니스 정보관리 (결제, 정산 등 정보 관리) | 이벤트/캠페인 관리 | 충전, 송금, 정산, 결제 정보 관리
머니 충전, 송금, 정산, 결제, 회계 시스템 연계, ... --> 회계 시스템 연계 관리 | 감사 관련 정보 관리(AML/STR/CTR, ...)

#### 고수준(사용자 입장) 시나리오, 케이스 정의하기 1 - 송금
**전제**
- 계좌 등록이 완료된 정산 상태의 고객(회원)이 있다.
- 마이페이와 연계된 은행이 있다.
- 마이페이 회원 뿐만 아니라, 외부 은행 계좌로도 송금이 가능하다.
- 송금 수수료가 존재한다.
- 마이페이 법인 계좌에는 추분한 금액이 존재한다.
**조건(when - 행동)**
- 고객의 마이머니와 연계된 계좌의 잔액은 송금하고자 하는 금액과 수수료의 합보다 많다.
- 외부 은행 계좌는 모두 펌뱅킹 계약 및 시스템 연계가 되어 있다.
- 고객은 타 고객 또는 외부 은행 계좌에 송금 요청을 한다.
**결과**
- 타 고객의 마이머니가 송금하고자 했던 금액만큼 충전된다.
- 외부 은행 계좌로부터 정산 송금처리 응답을 받는다.

#### 고수준(사용자 입장) 시나리오, 케이스 정의하기 2 - 정산
**전제**
- 계좌 등록이 완료된 정상 상태의 고객(회원)이 있다.
- 계좌 등록이 완료된 가맹점주(회원)가 있다.
- 정상 처리 된, 결제 전표가 1개 이상 존재한다.
- 결제 수수료가 존재한다.
- 마이페이 법인 계좌에는 충분한 금액이 존재한다.
**조건(When - 행동)**
- 주기적으로 정산을 위한 작업이 실행된다.
- 정상 처리 된 전표를 계산하여, 정산 완료된 금액에서, 결제 수수료만큼 제한 금액이 마이페이로부터 가맹점주 계좌로 송금 요청한다.
**결과**
- 1개 이상의 정산 처리 된 결제 건들의 전표 금액의 총합 만큼 사전 등록된 가맹점주의 계좌로 이체된다.

### 시스템 작업 정의하기
마이페이 라는 시스템이 해야할 일을 정의하기
- 회원 가입해 줘, 가맹점 등록해 줘
- 마이머니 20,000원을 충전해줘
- Daniel(or ABC은행 112-34)에게 송금해줘
- NoNo 치킨에서 30,000원을 결제해 줘
- 정산을 통해 완료된 결제 건들을 처리해 줘
- 결제 수수료를 변경해 줘

### 시스템 커맨드 정의하기
정의된 시스템 작업들을 기준으로, 주체와 커맨드(도메인 모델 데이터의 변경) 작업 정의하기 
- 회원 가입해 줘, 가맹점 등록해 줘 -----> (고객 가맹점) createMembership
- 마이머니 20,000원을 충전해줘 -----> (고객) rechargeMyMoney
- Daniel(or ABC은행 112-34)에게 송금해줘 -----> (고객) remittanceMoney 
- NoNo 치킨에서 30,000원을 결제해 줘 -----> (고객) payWithMyMoney
- 정산을 통해 완료된 결제 건들을 처리해 줘 -----> (직원) settlement
- 결제 수수료를 변경해 줘 -----> (직원) modifyCommission

#### 결국, 시스템이 무슨 일을 해야 하는지를 정의
(고객 가맹점) createMembership   
(고객) rechargeMyMoney
(고객) remittanceMoney
(고객) payWithMyMoney
(직원) settlement
(직원) modifyCommission

이러한 작업들을 통해 알고자 하는 것?
--> 서비스의 식별, 그리고 효과적인 아키텍처 디자인/설계
시스템이 무슨일을 해야하고 어떤 비즈니스 / 엔지니어링 특성을 가지며 이로 인해 아키텍처에 영향을 미치는지 파악

e.g.1 정산 작업의 경우, 매우 많은 결제 건들을 ㅈ안정적으로 실패 없이 처리 하기 위한 아키텍처, 기술 스택 등을 고민
--> 재시도, 큐잉, 정산 주기/금액에 대한 고민, 은행 계약상 한계 등 고민

e.g.2 외부 시스템 호출이 매우 잦다는 엔지니어링 특성, 호출 카운트 마다 수수료 과금된다는 비즈니스 특성
--> 비교적 더 자주 실패에 대한 가능성 존재
--> 성공/실패에 대한 기록과, 꼭 필요한 경우네만 재시도 판단 필요

## 마이 페이의 시스템 작업과 서비스 식별하기
### 시스템 작업 기반, "서비스" 식별하기 - 앞선 작업들의 조합
![MSA_서비스_식별.png](images/MSA_서비스_식별.png)

### 모놀리식 마이페이에서 분리/분해 - Based on DDD with SRP/CCP
DDD(Domain Driven Design) 기반, 분해지침에 따른 서비스 식별/분리/통합
- 하위 도메인 (Sub-Domain)
  - 어플리케이션(시스템)의 문제 공간을 가리키는 용어 (Problem Space)
    - 비즈니스, 엔지니어링 특성을 고려한 아키텍처 설계
    - 비즈니스 능력을 기준으로 분해하는 것과 유사
  - 경계 컨텍스트 (Bounded Context)
    - 마이크로 서비스 간에는 경계가 분명한 책임(Context)을 가지고 있어야 한다.
  - 단일 책임 원칙(Single Responsibility Principle), 공동 폐쇄 원칙(Common Closure Principle)
    - 분해를 위한 가이드 라인

 **비즈니스/엔지니어링 적 특성을 고려한 아키텍처 설계**
 
- 금융이라는 비즈니스 특성상, "송금", "정산" 도메인 필요하다고 판단
  - 일부 기능은 결제와 뱅킹 모듈에서 Bounded-context, Sub-domain 개념을 활용하여 분리, 송금/정산으로 통합.
- 단일 책임 원칙에 의거(Single Responsibility Principle),
  - "돈을 보낸다"라는 행동이 **응집된 하나의 비즈니스** 성격
    - "**송금**"이라는 서비스를 식별
  - "주기적인 스케쥴링 및 결제 내역들의 Integration, 후속 핸들링 책임이라는 **별도의 응집된 비즈니스**"
    - "**정산**" 이라는 서비스를 식별
- 공동 폐쇄 원칙(Common Closure Principle)에 의거,
  - 뱅킹이 가지고 있던 송금 요청 내역의 관리라는 "Class"를 송금 서비스의 책임으로 변경
    - 즉, 외부 계좌에 대한 송금 요청 내역의 관리(Class)와 **송금 서비스가 책임질 도메인**과 동일한 유형의 변경으로 간주
  - **결제**가 가지고 있던 **주기적인 정산 및 재시도 등에 대한 관리라는 "Class"** 를 정산 서비스의 책임으로 변경
    - 즉, **주기적인 정산 및 재시도 등에 대한 관리** 를 **정산 서비스가 책임질 도메인**과 동일한 유형의 변경으로 갖누
  - 프랜차이즈 라는 모듈은 회원 관리 도메인으로 통합

- 앞서 시스템이 하는 작업들을 식별하는 과정에서 알게 된 엔지니어링/ 비즈니스적인 특성을 고려한 아키텍처 설계
  - 대용량 데이터를 처리하는 "정산" (높은 cpu, container, memory)
  - 잦은 외부 인프라 호출을 위한 "뱅킹"

![MSA_My_Pay_아키텍처.png](images/MSA_My_Pay_아키텍처.png)

### 아키텍처를 가지는 마이 페이를 이루는 서비스
#### Membership Service(멤버십 서비스)
- 고객(회원/가맹점)을 관리하고 계좌 등록, 인증 등 마이페이의 고객을 관리하고 편의 기능을 제공하는 서비스

#### Banking Service(뱅킹 서비스)
- 외부 은행과의 직접적인 통신을 담당하고, 펌뱅킹 계약이나 수수료 관리 등 외부 은행 사용과 관련된 모든 기능을 제공하는 서비스

#### Money Service(머니 서비스)
- 고객의 선불 충전 금액(머니)을 관리하고, 이에 대해 다양한 쿼리를 제공할 수 있는 서비스

#### Remittance Service(송금 서비스)
- "송금" 이라는 비즈니스 과정 전체를 관리하고, 트랜잭션에 대한 책임을 가지는 서비스

#### Payment Service(결제 서비스)
- "결제" 이라는 비즈니스 과정 전체를 관리하고, 트랜잭션에 대한 책임을 가지는 서비스

#### Settlement Service (정산 서비스)
- 주기적으로 정산 작업을 진행하며, 여기서 생기는 모든 과정을 관리하는 서비스

### 결론
#### 기능 요건 정의
- "어떤 일을 해야 하는 시스템인지" 비즈니스 도메인의 관점에서 기술

#### 도메인 모델 도출
- 어떤 "도메인 모델"(관리해야 할 대상, CRUD가 필요한 대상) 이 존재할 수 있는지 식별

#### 고수준 시나리오, 케이스 정의
- 도메인 모델들을 사용하여, 사용자 입장에서 어떤 시나리오들을 만족시켜야 하는지

#### 시스템 작업 식별
- 도메인 모델 간의 상호 관계와, 이들이 어떤 "작업"을 해야할 지를 구체적이고 상세하게 정의

Business - 분리/분해/통합 ----> Micro Service


## Application Dockerizing
### 마이페이회원정보 변경 기능 추가, Dockerizing
- Docker는 어떤 역할을 해주는 지 학습
  - 일반적인 CI/CD 과정에서의 Dockerizing
  - 마이 페이에서의 Dockerizing

### Dockerizing
- 어플리케이션을 docker build 를 통해 image 로 만드는 작업.(Containerizing)
- 일반적으로 Dockerfile 이라는 파일에, image 를 빌드하는 일련의 작업을 정의

**장점**: 운영 체제와 하드웨어에 독립적(JVM)//환경 일관성//격리성//빠른 배포와 롤백 가능
**단점**: 러닝 커브//docker 라는 추가적인 리소스//보안 이슈//이미지 크기 최적화 어려움

- 일반적인 CI/CD 과정에서의 Dockerizing
  - 코드 푸시 -> CI(Continuous Integration) 현재 추세는 build 뿐만아니라 image 까지 만듦,, -> CD(Continuous Deployment)

## docker-compose 로 실행
### Docker-compose
- docker image들을 이용해서, 여러개의 컨테이너를 실행하고 이 컨테이너들의 관리를 위한 도구
- 여러 컨테이너로 구성된 복잡한 애플리케이션 환경을 관리해 주는 도구
- 주로 docker-compose.yml 파일에 정의를 하고, 네트워크, 볼륨 등을 정의하여 한번에 여러 컨테이너를 실행

여러 어플리케이션을 image로 만들고, 이 image 들을 Local (1 Computer) 환경에서 실행할 수 있도록 지원.

**"제한된 환경에서 MSA 환경을 구성해 보고 학습하는데 있어서 적절한 도구"**

## 뱅킹 서비스 정의 하기, 도메인 모셀 설계하기
### 뱅킹 서비스 정의
- 외부 은행과의 직접적인 통신을 담당하고, 펌뱅킹 계약이나 수수료 관리 등 외부 은행 사용과 관련되 모든 기능을 제공하는 서비스
  - A 계좌로부터 출금하여, B 계좌로 입금을 하라는 요청을 받아서, 은행망으로 펌뱅킹 명령 송신
  - 현재 계약 되어있는 은행들의 상태와 만료 기간 등을 관리
  - 모든 펌뱅킹 명령에 대해서 기록하고, 정상적으로 완료된 명령들의 수수료 계산
  - 특정 계좌가 정상 상태인지 체크하는 요청 지원

![MSA_뱅킹_도메인_모델_정의하기.png](images/MSA_뱅킹_도메인_모델_정의하기.png)
- To Target은 회원, 외부 인행계좌일 수 있다.
- From Target은 항상 회원이다.
계좌연동, 펌뱅킹

![MSA_MVP.png](images/MSA_MVP.png)
- **뱅킹을 연동하지 않고 이정도를 MVP로 계획한다.**
- 외부 은행과 입/출금 요청 펌뱅킹 통신을 담당하고, 내부 고객의 계좌 정보를 등록하는 서비스

### 뱅킹 서비스 패키지 설계, API 식별
#### 도메인 모델기반, 모델 객체 식별해보기
**"계좌 연동"**
- RegisteredBankAccount (고객의 등록된 계좌)
- RegisteredBankAccountHistory
**"펌뱅킹 관련""**
- RequestFirmbanking (받는사람, 보내는사람(은행정보), 금액, 시간)
- RequestFirmbankingHistory
- BankAccount (외부 은행 수많은 정보, 개설, 폐쇄, 세금)

#### API 설계
##### Query
- 입금/출금 요청(펌뱅킹) 내역 조회
  - find - FirmBankingInfo ( -by-membershipId)
  - Request: membershipId
  - Response: Firmbanking Object
- 고객의 연동된 계좌 (고객 계좌 연동정보) 조회
  - find - RegisteredBankAccount(-by-membershipId)
    - Request: membershipId
    - Response: RegisteredBankAccount Object
##### Command
- 고객 정보에 대해 요청된 Account 정보를 매핑, 연동
  - register-BankAccount(-with-membershipId)
    - Request: membershipId, BankAccount
    - Response: RegisteredBankAccount Object
- 실제 실물 계좌에서의 입/출금을 요청하는 펌뱅킹을 요청, 수행
  - request - Firmbanking - (-to Remittance)-(-with BankAccount)
    - Request: from Bank Account, to Bank Account, Money
    - Response: RequestFirmbankingUUID

### 뱅킹 서비스 MVP 개발2 (은행으로 입금 및 출금 요청하기)
#### Command 
- 실제 실물 계좌에서의 입/출금을 요청하는 펌뱅킁을 요청, 수행
  - request - Firmbanking - (-to Remittance) - (-with BankAccount)
    - Request: from Bank Account, to Bank Account, Money
    - Response: RequestFirmbankingUUID
#### Query
- 입금/출금 요청(펌뱅킹) 내역 조회
  - find - FirmBankingInfo - (-by-membershipId)
    - Request: membershipId
    - Response: Firmbanking Object
